defmodule Zoi.Error do
  @moduledoc """
  Represents a validation error with detailed information.

  ## Fields

    - `code`: Error code
    - `issue`: A tuple with the message and keyword with error variables.
    - `message`: Description of the error, formed from the issue message and variables.
    - `path`: A list representing the path to the location of the error.

  ## Errors

  All `Zoi` errors have a code that can be used to identify the type of error.
  The following error codes are defined:
    - `:invalid_type`
    - `:invalid_literal`
    - `:invalid_tuple`,
    - `:unrecognized_key`
    - `:invalid_enum_value`
    - `:less_than`
    - `:greater_than`
    - `:less_than_or_equal_to`
    - `:greater_than_or_equal_to`
    - `:invalid_format`
    - `:custom`

  ## Example

  The error struct follows this format:

      %Zoi.Error{
        code: :invalid_type,
        issue: {"invalid type: expected %{expected}", [expected: "string"]},
        message: "invalid type: expected string",
        path: [:user, :name]
      }

  The `:message` field is generated by replacing the placeholders in the `:issue` message.
  This allows for dynamic error messages that provide context about the validation failure and possibility for
  localization using `Gettext` or similar libraries.
  """

  @typedoc "The path to the location of the error."
  @type path :: [atom() | binary() | integer()]

  @typedoc """
  Error struct containing detailed information about a validation error.
  """
  @type t :: %__MODULE__{
          code: atom(),
          issue: {binary(), keyword()} | nil,
          message: binary(),
          path: path()
        }
  defexception [:code, :issue, :message, path: []]

  @spec new(keyword()) :: t()
  def new(opts \\ []) when is_list(opts) do
    Keyword.validate!(opts, [:code, :issue])
    message = render_message_from_issue(opts[:issue])

    struct!(__MODULE__, [{:message, message} | opts])
  end

  @impl true
  def exception(opts) do
    struct!(__MODULE__, opts)
  end

  def prepend_path(%__MODULE__{} = error, path) when is_list(path) do
    %{error | path: path ++ error.path}
  end

  def message(%__MODULE__{message: message}) do
    message
  end

  defp render_message_from_issue({message, opts}) do
    opts =
      Enum.map(opts, fn {k, v} ->
        {to_string(k), v}
      end)
      |> Enum.into(%{})

    Regex.replace(~r"%{(\w+)}", message, fn _, key ->
      Map.get(opts, key) |> to_string()
    end)
  end

  ## Error types

  @spec invalid_type(binary()) :: t()
  def invalid_type(expected, opts \\ []) do
    if msg = opts[:custom_message] do
      custom_error(msg)
    else
      new(
        code: :invalid_type,
        issue: {"invalid type: expected %{expected}", [expected: expected]}
      )
    end
  end

  @spec invalid_literal(any()) :: t()
  def invalid_literal(value, opts \\ []) do
    if msg = opts[:custom_message] do
      custom_error(msg)
    else
      new(
        code: :invalid_literal,
        issue: {"invalid literal: expected %{expected}", [expected: value]}
      )
    end
  end

  @spec invalid_enum_value([tuple()]) :: t()
  def invalid_enum_value(enum, opts \\ []) when is_list(enum) do
    if msg = opts[:custom_message] do
      custom_error(msg)
    else
      expected = Enum.map_join(enum, ", ", fn {_key, value} -> value end)

      new(
        code: :invalid_enum_value,
        issue: {"invalid enum value: expected one of %{expected}", [expected: expected]}
      )
    end
  end

  @spec invalid_tuple(non_neg_integer(), non_neg_integer(), keyword()) :: t()
  def invalid_tuple(expected_length, actual_length, opts \\ []) do
    if msg = opts[:custom_message] do
      custom_error(msg)
    else
      new(
        code: :invalid_tuple,
        issue: {
          "invalid tuple: expected length %{expected_length}, got %{actual_length}",
          [expected_length: expected_length, actual_length: actual_length]
        }
      )
    end
  end

  @spec unrecognized_key(atom() | binary() | integer()) :: t()
  def unrecognized_key(key) do
    new(
      code: :unrecognized_key,
      issue: {"unrecognized key: '%{key}'", [key: key]}
    )
  end

  @spec custom_error(binary()) :: t()
  def custom_error(message) do
    new(
      code: :custom,
      issue: {message, []}
    )
  end
end

defmodule Zoi.ParseError do
  @moduledoc false
  defexception [:errors]

  @impl true
  def exception(opts) do
    struct!(__MODULE__, opts)
  end

  @impl true
  def message(%__MODULE__{errors: errors}) when is_list(errors) do
    """
    Parsing error:

    #{Zoi.prettify_errors(errors)}
    """
  end
end
