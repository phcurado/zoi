defmodule Zoi.Error do
  @moduledoc """
  Represents a validation error with detailed information.

  ## Fields

    - `code`: Error code
    - `issue`: A tuple with the message and keyword with error variables.
    - `message`: Description of the error, formed from the issue message and variables.
    - `path`: A list representing the path to the location of the error.

  ## Errors

  All `Zoi` errors have a code that can be used to identify the type of error.
  The following error codes are defined:
    - `:invalid_type`
    - `:invalid_literal`
    - `:invalid_tuple`
    - `:unrecognized_key`
    - `:invalid_enum_value`
    - `:required`
    - `:less_than`
    - `:greater_than`
    - `:less_than_or_equal_to`
    - `:greater_than_or_equal_to`
    - `:invalid_length`
    - `:invalid_format`
    - `:custom`

  ## Example

  The error struct follows this format:

      %Zoi.Error{
        code: :invalid_type,
        issue: {"invalid type: expected string", [type: :string]},
        message: "invalid type: expected string",
        path: [:user, :name]
      }

  The `:message` field is generated by replacing the placeholders in the `:issue` message.
  This allows for dynamic error messages that provide context about the validation failure and possibility for
  localization using `Gettext` or similar libraries. Usually the `issue` and `message` will share the same content,
  but the `issue` retains the original template and variables for further processing if needed.
  """

  @typedoc "The path to the location of the error."
  @type path :: [atom() | binary() | integer()]

  @typedoc """
  Error struct containing detailed information about a validation error.
  """
  @type t :: %__MODULE__{
          code: atom(),
          issue: {binary(), keyword()} | nil,
          message: binary(),
          path: path()
        }
  defexception [:code, :issue, :message, path: []]

  @spec new(keyword() | map()) :: t()
  def new(opts \\ [])

  def new(opts) when is_map(opts) do
    opts = Map.to_list(opts)
    new(opts)
  end

  def new(opts) when is_list(opts) do
    Keyword.validate!(opts, [:code, :issue, :path, :message])
    {msg, opts} = Keyword.pop(opts, :message)

    if msg do
      custom_error(msg)
      |> prepend_path(Keyword.get(opts, :path, []))
    else
      {issue, opts} = Keyword.pop(opts, :issue)
      {message, issue} = render_message_from_issue(issue)

      struct!(__MODULE__, [{:message, message}, {:issue, issue} | opts])
    end
  end

  @impl true
  def exception(opts) do
    struct!(__MODULE__, opts)
  end

  def prepend_path(%__MODULE__{} = error, path) when is_list(path) do
    %{error | path: path ++ error.path}
  end

  def message(%__MODULE__{message: message}) do
    message
  end

  defp render_message_from_issue({issue, opts}) do
    parsed_opts =
      Enum.map(opts, fn {k, v} ->
        {to_string(k), v}
      end)
      |> Enum.into(%{})

    message =
      Regex.replace(~r"%{(\w+)}", issue, fn _, key ->
        Map.get(parsed_opts, key) |> to_string()
      end)

    {message, {issue, opts}}
  end

  defp render_message_from_issue(nil) do
    {nil, {nil, []}}
  end

  defp render_message_from_issue(issue) do
    render_message_from_issue({issue, []})
  end

  ## Error types

  @spec invalid_type(binary()) :: t()
  def invalid_type(type, opts \\ []) do
    {msg, opts} = Keyword.pop(opts, :error)

    if msg do
      custom_error(msg, type: type)
    else
      {issue, opts} = Keyword.pop(opts, :issue)

      opts =
        Keyword.merge(
          [
            {:code, :invalid_type},
            {:issue, {issue || "invalid type: expected #{type || "nil"}", [type: type]}}
          ],
          opts
        )

      new(opts)
    end
  end

  @spec invalid_literal(any()) :: t()
  def invalid_literal(value, opts \\ []) do
    {msg, opts} = Keyword.pop(opts, :error)

    if msg do
      custom_error(msg, expected: value)
    else
      new([
        {:code, :invalid_literal},
        {:issue, {"invalid literal: expected %{expected}", [expected: value]}} | opts
      ])
    end
  end

  @spec invalid_enum_value([tuple()]) :: t()
  def invalid_enum_value(enum, opts \\ []) when is_list(enum) do
    {msg, _opts} = Keyword.pop(opts, :error)

    expected = Enum.map_join(enum, ", ", fn {_key, value} -> value end)

    if msg do
      custom_error(msg, expected: expected)
    else
      new(
        code: :invalid_enum_value,
        issue: {"invalid enum value: expected one of %{values}", [type: :enum, values: expected]}
      )
    end
  end

  @spec invalid_tuple(non_neg_integer(), non_neg_integer(), keyword()) :: t()
  def invalid_tuple(expected_length, actual_length, opts \\ []) do
    {msg, opts} = Keyword.pop(opts, :error)

    if msg do
      custom_error(msg, expected_length: expected_length, actual_length: actual_length)
    else
      new([
        {:code, :invalid_tuple},
        {:issue,
         {
           "invalid tuple: expected length %{expected_length}, got %{actual_length}",
           [expected_length: expected_length, actual_length: actual_length]
         }}
        | opts
      ])
    end
  end

  @spec unrecognized_key(atom() | binary() | integer()) :: t()
  def unrecognized_key(key) do
    new(
      code: :unrecognized_key,
      issue: {"unrecognized key: '%{key}'", [key: key]}
    )
  end

  @spec required(atom() | binary() | integer()) :: t()
  def required(key, opts \\ []) do
    new([
      {:code, :required},
      {:issue, {"is required", [key: key]}} | opts
    ])
  end

  @spec less_than_or_equal_to(atom(), any(), keyword()) :: t()
  def less_than_or_equal_to(type, max, opts \\ []) do
    {msg, opts} = Keyword.pop(opts, :error)

    if msg do
      custom_error(msg, count: max)
    else
      message =
        case type do
          :string -> "too big: must have at most %{count} character(s)"
          :array -> "too big: must have at most %{count} item(s)"
          :number -> "too big: must be at most %{count}"
          :date -> "too big: must be at most %{count}"
        end

      opts =
        Keyword.merge(
          [
            {:code, :less_than_or_equal_to},
            {:issue, {message, [count: max]}}
          ],
          opts
        )

      new(opts)
    end
  end

  @spec greater_than_or_equal_to(atom(), any(), keyword()) :: t()
  def greater_than_or_equal_to(type, min, opts \\ []) do
    {msg, opts} = Keyword.pop(opts, :error)

    if msg do
      custom_error(msg, count: min)
    else
      message =
        case type do
          :string -> "too small: must have at least %{count} character(s)"
          :array -> "too small: must have at least %{count} item(s)"
          :number -> "too small: must be at least %{count}"
          :date -> "too small: must be at least %{count}"
        end

      opts =
        Keyword.merge(
          [
            {:code, :greater_than_or_equal_to},
            {:issue, {message, [count: min]}}
          ],
          opts
        )

      new(opts)
    end
  end

  @spec greater_than(atom(), any(), keyword()) :: t()
  def greater_than(type, min, opts \\ []) do
    {msg, opts} = Keyword.pop(opts, :error)

    if msg do
      custom_error(msg, count: min)
    else
      message =
        case type do
          :array -> "too small: must be greater than %{count} item(s)"
          :number -> "too small: must be greater than %{count}"
          :date -> "too small: must be greater than %{count}"
        end

      opts =
        Keyword.merge(
          [
            {:code, :greater_than},
            {:issue, {message, [count: min]}}
          ],
          opts
        )

      new(opts)
    end
  end

  @spec less_than(atom(), any(), keyword()) :: t()
  def less_than(type, max, opts \\ []) do
    {msg, opts} = Keyword.pop(opts, :error)

    if msg do
      custom_error(msg, count: max)
    else
      message =
        case type do
          :array -> "too big: must be less than %{count} item(s)"
          :number -> "too big: must be less than %{count}"
          :date -> "too big: must be less than %{count}"
        end

      opts =
        Keyword.merge(
          [
            {:code, :less_than},
            {:issue, {message, [count: max]}}
          ],
          opts
        )

      new(opts)
    end
  end

  @spec invalid_length(atom(), non_neg_integer(), keyword()) :: t()
  def invalid_length(type, length, opts \\ []) do
    {msg, opts} = Keyword.pop(opts, :error)

    if msg do
      custom_error(msg, count: length)
    else
      message =
        case type do
          :string -> "invalid length: must have %{count} character(s)"
          :array -> "invalid length: must have %{count} item(s)"
        end

      opts =
        Keyword.merge(
          [
            {:code, :invalid_length},
            {:issue, {message, [count: length]}}
          ],
          opts
        )

      new(opts)
    end
  end

  @spec invalid_ending_string(binary(), keyword()) :: t()
  def invalid_starting_string(prefix, opts \\ []) do
    {msg, opts} = Keyword.pop(opts, :error)

    if msg do
      custom_error(msg, prefix: prefix)
    else
      opts =
        Keyword.merge(
          [
            {:code, :invalid_format},
            {:issue,
             {
               "invalid format: must start with '%{value}'",
               [value: prefix]
             }}
          ],
          opts
        )

      new(opts)
    end
  end

  @spec invalid_ending_string(binary(), keyword()) :: t()
  def invalid_ending_string(suffix, opts \\ []) do
    {msg, opts} = Keyword.pop(opts, :error)

    if msg do
      custom_error(msg, suffix: suffix)
    else
      opts =
        Keyword.merge(
          [
            {:code, :invalid_format},
            {:issue,
             {
               "invalid format: must end with '%{value}'",
               [value: suffix]
             }}
          ],
          opts
        )

      new(opts)
    end
  end

  @spec invalid_format(Regex.t(), keyword()) :: t()
  def invalid_format(pattern, opts \\ []) do
    {msg, opts} = Keyword.pop(opts, :error)
    {format, opts} = Keyword.pop(opts, :format)
    default_issue_opts = [pattern: Regex.source(pattern), regex: pattern]

    if msg do
      custom_error(msg, default_issue_opts)
    else
      {message, opts} =
        Keyword.pop(opts, :internal_message, "invalid format: must match pattern %{pattern}")

      issue_opts =
        case format do
          nil -> default_issue_opts
          _format -> [{:format, format} | default_issue_opts]
        end

      opts =
        Keyword.merge(
          [
            {:code, :invalid_format},
            {:issue, {message, issue_opts}}
          ],
          opts
        )

      new(opts)
    end
  end

  @spec custom_error(binary(), keyword()) :: t()
  def custom_error(message, opts \\ []) do
    new(
      code: :custom,
      issue: {message, opts}
    )
  end
end

defmodule Zoi.ParseError do
  @moduledoc false
  defexception [:errors]

  @impl true
  def exception(opts) do
    struct!(__MODULE__, opts)
  end

  @impl true
  def message(%__MODULE__{errors: errors}) when is_list(errors) do
    """
    Parsing error:

    #{Zoi.prettify_errors(errors)}
    """
  end
end
